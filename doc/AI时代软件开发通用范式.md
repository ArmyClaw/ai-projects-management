# AI时代软件开发通用范式

> **版本**: v1.0  
> **状态**: 生产就绪  
> **适用**: AI辅助软件开发项目

---

## 一、核心流程架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    AI时代敏捷开发流程                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐        │
│  │ 需求定义 │ ──►│ 架构设计 │ ──►│ 迭代规划 │ ──►│ 敏捷开发 │        │
│  │   AI辅助 │    │   AI辅助 │    │   AI辅助 │    │ AI驱动   │        │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘        │
│         │                │                │                │                  │
│         ▼                ▼                ▼                ▼                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐        │
│  │PRD文档   │    │技术架构   │    │任务分解   │    │测试驱动   │        │
│  │用户故事   │    │API设计    │    │工时估算   │    │CI/CD集成  │        │
│  │功能清单   │    │数据模型   │    │迭代排期   │    │代码Review │        │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 二、分阶段详解

### 阶段一：需求定义（AI辅助）

**核心目标**：明确做什么

| 活动 | AI角色 | 人工角色 | 产出 |
|------|---------|----------|------|
| 头脑风暴 | 提供竞品分析 | 主导方向 | 原始需求清单 |
| 需求整理 | 生成结构化文档 | 确认准确性 | PRD文档 |
| 功能拆解 | 推荐最佳实践 | 决策取舍 | 功能清单 |
| 用户旅程 | 设计交互流程 | 场景确认 | 用户旅程图 |

**AI辅助技巧**：
- 提供行业最佳实践案例
- 自动生成用户故事模板
- 识别需求遗漏和冲突

---

### 阶段二：架构设计（AI辅助）

**核心目标**：明确怎么做

| 活动 | AI角色 | 人工角色 | 产出 |
|------|---------|----------|------|
| 技术选型 | 推荐技术栈 | 最终决策 | 技术架构文档 |
| API设计 | 生成RESTful模板 | 确认业务逻辑 | API设计文档 |
| 数据建模 | 推荐数据模型 | 优化调整 | 数据库Schema |
| 目录结构 | 生成项目骨架 | 确认调整 | 项目结构 |

**AI辅助技巧**：
- 根据项目规模推荐技术栈
- 自动生成TypeScript类型定义
- 提供安全认证方案

---

### 阶段三：迭代规划（AI辅助）

**核心目标**：明确什么时候做

```
迭代规划公式：
┌─────────────────────────────────────────────┐
│  任务拆解 → 复杂度估算 → 工时分配 → 迭代排期  │
│      AI         AI          人工        AI   │
└─────────────────────────────────────────────┘
```

**规划原则**：
- 单迭代时长：15-30分钟（微迭代）或2-4小时（标准迭代）
- 任务粒度：每个任务可独立测试和交付
- 优先级排序：P0必须 > P1应该 > P2可以

**AI辅助技巧**：
- 根据代码量估算开发时间
- 识别任务依赖关系
- 推荐并行开发策略

---

### 阶段四：敏捷开发（AI驱动）

**核心模式：测试驱动开发（TDD）**

```
┌─────────────────────────────────────────────────────────────┐
│                    单迭代开发流程                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Step 1: 编写测试                                         │
│  ├── AI根据API设计生成测试用例模板                        │
│  └── 人工补充业务场景覆盖                                 │
│                                                             │
│  Step 2: 生成代码                                         │
│  ├── AI根据测试生成实现代码                              │
│  └── 人工Review并优化                                     │
│                                                             │
│  Step 3: 运行测试                                         │
│  ├── 本地运行单元测试                                     │
│  └── CI流水线自动化验证                                   │
│                                                             │
│  Step 4: 代码提交                                         │
│  ├── Git提交（feat/fix/docs前缀）                        │
│  └── 自动生成CHANGELOG                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**质量门禁**：
```
代码合并前必须通过：
├── ✅ ESLint 0错误
├── ✅ TypeScript编译通过
├── ✅ 单元测试100%通过
├── ✅ 测试覆盖率 >= 80%
└── ✅ 代码Review通过
```

---

## 三、AI辅助最佳实践

### AI协作模式

| 任务类型 | AI分配 | 人工分配 | 原因 |
|----------|--------|----------|------|
| 重复性代码 | 80% | 20% | 减少枯燥工作 |
| 样板代码 | 90% | 10% | CRUD生成 |
| 测试用例 | 70% | 30% | 基础场景覆盖 |
| 文档编写 | 80% | 20% | 注释+API文档 |
| 架构决策 | 20% | 80% | 需要经验判断 |
| 业务逻辑 | 30% | 70% | 需要领域知识 |
| 代码Review | 40% | 60% | 质量把关 |

---

### 工具链配置

```
┌─────────────────────────────────────────────────────────────────┐
│                    AI开发工具链                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  代码生成                                                        │
│  ├── Claude Code / Cursor / Codex                              │
│  └── Continue / Tabby                                          │
│                                                                 │
│  测试框架                                                       │
│  ├── 后端: Vitest + Supertest                                  │
│  ├── 前端: Vitest + Vue Test Utils                             │
│  └── E2E: Playwright                                          │
│                                                                 │
│  代码质量                                                       │
│  ├── ESLint + Prettier                                         │
│  ├── TypeScript严格模式                                         │
│  └── SonarQube (可选)                                         │
│                                                                 │
│  CI/CD                                                         │
│  ├── GitHub Actions                                            │
│  ├── 自动化测试                                                 │
│  └── 自动部署                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 四、效率指标对比

| 指标 | 传统开发 | AI辅助开发 | 提升 |
|------|----------|------------|------|
| 需求文档编写 | 2-3天 | 4-6小时 | **3-4x** |
| 原型设计 | 1-2周 | 1-2天 | **5-7x** |
| 代码编写 | 4-6周 | 1-2周 | **3-4x** |
| 单元测试 | 2-3周 | 3-5天 | **4x** |
| API文档 | 1周 | 1天 | **5x** |

---

## 五、流程优化建议

### 可优化领域

| 领域 | 当前状态 | 优化方向 | 预期收益 |
|------|----------|----------|----------|
| 需求管理 | 文档驱动 | **需求即代码** | 追踪变更 |
| 测试覆盖 | 单元测试 | **契约测试** | 前后端解耦 |
| 部署 | 手动发布 | **GitOps** | 一键部署 |
| 监控 | 缺失 | **全链路追踪** | 快速定位 |
| 文档 | 分离维护 | **代码即文档** | 自动同步 |

---

### 新增最佳实践

**1. 需求即代码（Requirements as Code）**
```typescript
// 需求直接关联测试
const requirements = {
  'REQ-001': '用户必须能够登录',
  'REQ-002': '用户只能看到自己的数据',
  // 每个需求对应测试用例
  testCases: ['login.test.ts', 'data-isolation.test.ts']
}
```

**2. AI Prompt版本管理**
```
├── prompts/
│   ├── core/           # 核心功能prompt
│   ├── tests/          # 测试生成prompt
│   └── docs/           # 文档生成prompt
├── VERSION             # prompt版本
└── CHANGELOG.md       # prompt变更记录
```

**3. 自动化架构检查**
```yaml
# .archcheck.yml
rules:
  - api-versioning: required
  - error-handling: must-have
  - authentication: must-have
  - rate-limiting: recommended
```

---

## 六、成熟度模型

```
┌─────────────────────────────────────────────────────────────────┐
│                    流程成熟度模型                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  L5: 自适应（AI完全自主）                                       │
│      ├── AI自动识别需求变化                                      │
│      ├── 自动调整架构设计                                        │
│      └── 自我修复和优化                                         │
│                                                                 │
│  L4: 智能化（AI高度参与）                                       │
│      ├── AI辅助需求分析                                         │
│      ├── AI自动生成测试                                         │
│      └── 智能代码Review                                        │
│                                                                 │
│  L3: 标准化（流程规范）                                         │
│      ├── 明确角色分工                                          │
│      ├── 标准交付物模板                                        │
│      └── 度量指标体系                                          │
│                                                                 │
│  L2: 可重复（基础实践）                                         │
│      ├── 迭代流程建立                                          │
│      ├── 持续集成实践                                          │
│      └── 基本测试覆盖                                          │
│                                                                 │
│  L1: 初始（混乱）                                              │
│      ├── 无标准流程                                            │
│      ├── 手工测试为主                                          │
│      └── 文档缺失                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 七、核心原则

```
1. 人机协作，而非替代
   ├── AI做重复，人做决策
   ├── AI生成骨架，人优化细节
   └── AI辅助测试，人保证质量

2. 快速迭代，持续验证
   ├── 小步快跑（15分钟迭代）
   ├── 自动化质量门禁
   └── 每次提交都可部署

3. 文档即代码
   ├── 设计文档代码化
   ├── API文档自动化
   └── 变更记录版本化

4. 质量内建
   ├── 测试先于开发
   ├── 代码Review制度化
   └── 安全左移
```

---

## 八、检查清单

### 每次迭代前

- [ ] 需求清晰可测试
- [ ] 任务拆解完成
- [ ] 测试用例设计完成

### 每次迭代中

- [ ] 测试驱动开发
- [ ] ESLint 0错误
- [ ] TypeScript编译通过

### 每次迭代后

- [ ] 测试100%通过
- [ ] 代码Review通过
- [ ] 提交信息规范
- [ ] 文档同步更新

---

## 九、行动指南

### 第一步：建立基础流程

```
├── 选择AI编程工具（Claude Code/Cursor）
├── 配置测试框架（Vitest）
└── 建立CI/CD流水线
```

### 第二步：标准化产出

```
├── 文档模板（PRD/API/架构）
├── 代码规范（ESLint + Prettier）
└── 提交规范（Conventional Commits）
```

### 第三步：持续优化

```
├── 收集效率指标
├── 优化AI Prompt
└── 完善工具链
```

---

## 十、总结

### 核心价值

| 维度 | 价值 |
|------|------|
| 开发效率 | 提升 **3-5倍** |
| 代码质量 | 保证 **100%测试覆盖** |
| 迭代速度 | **15分钟周期** |
| 人机协作 | **最佳平衡** |

### 适用场景

- ✅ 快速原型开发
- ✅ MVP快速验证
- ✅ 敏捷团队协作
- ✅ AI辅助编程项目
- ✅ 创业公司产品开发

### 不适用场景（修正说明）

> **重要澄清**：以下场景并非"绝对不能使用AI"，而是需要**分层治理**

#### 场景一：高度监管行业（医疗、金融）

| 领域 | AI可以做 | AI不能做 |
|------|----------|-----------|
| 医疗 | 病历结构化、报告生成 | 最终诊断、处方决策 |
| 金融 | 风险模型计算、报告生成 | 投资决策、合规判断 |

**适用模式**：人机分离
- 非核心模块：AI完全主导
- 核心模块：AI生成 → 专家Review → 合规审计

#### 场景二：硬实时系统

| 系统类型 | AI适用度 | 说明 |
|----------|-----------|------|
| 自动驾驶控制 | ❌ | 毫秒决策，人命关天 |
| 工业控制 | ⚠️ | 边缘AI可辅助，核心控制需谨慎 |
| 音视频处理 | ✅ | 降噪算法可AI辅助 |
| 嵌入式固件 | ⚠️ | 代码生成可用，逻辑验证需人工 |

**适用模式**：分层治理
- 安全关键层：禁止AI
- 非实时层：完全AI辅助
- 性能优化层：AI辅助+人工验证

#### 场景三：安全关键系统

| 安全领域 | AI适用度 | 说明 |
|----------|-----------|------|
| 加密实现 | ❌ | 必须使用经过验证的库 |
| 认证授权 | ⚠️ | 框架可用，业务逻辑需审计 |
| 入侵检测 | ✅ | 模式识别、异常检测 |
| 安全审计 | ✅ | 日志分析、漏洞扫描 |

**适用模式**：安全分层
- 底层代码：禁止AI生成
- 业务逻辑：AI+专家Review
- 上层功能：完全AI辅助

#### 通用公式

```
AI辅助适用度 = f(风险等级, 代码类型, 人工可审查性)

其中：
- 风险等级：低风险 → 高适用
- 代码类型：样板代码 → 高适用，业务逻辑 → 中适用，安全关键 → 低适用
- 人工可审查性：易审查 → 高适用
```

#### 核心原则

> **没有绝对不能AI辅助的场景，只有需要分层治理的场景**

| 原则 | 说明 |
|------|------|
| 风险分级 | 识别哪些代码高风险 |
| 人机分离 | 高风险代码人工，辅助代码AI |
| 审计追溯 | 所有AI生成代码可追踪 |
| 验证充分 | 关键逻辑多轮验证 |

---

## 附录：参考资源

- [AI辅助编程最佳实践](https://docs.anthropic.com/)
- [TDD开发模式](https://testdriven.io/)
- [敏捷开发方法论](https://agilemanifesto.org/)
- [CI/CD最佳实践](https://docs.github.com/en/actions)

---

**文档版本**: v1.1  
**更新时间**: 2026-02-20  
**适用项目**: AI辅助软件开发项目

---

## 📖 使用指南

### 如何使用本范式

1. **评估当前状态**：对照成熟度模型，确定所处阶段
2. **选择起点**：根据团队能力，选择L2或L3开始
3. **逐步演进**：不追求一步到位，持续迭代改进
4. **度量优化**：收集效率指标，持续优化流程

### 常见问题

**Q1: AI生成代码质量如何保证？**
A: 通过严格的代码Review、自动化测试、ESLint检查确保质量。

**Q2: 如何平衡AI效率和人工控制？**
A: 建立质量门禁，AI负责重复工作，人负责决策和Review。

**Q3: 团队如何适应这种模式？**
A: 渐进式引入，先在小团队试点，成功后再推广。

---

**祝您的AI辅助开发之旅顺利！** 🚀
